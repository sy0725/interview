1. ⭐ Promise에 대해 설명해주세요.

   - promise란 비동기 작업의 성공 실패 상태를 나타내는 객체로 비동기 작업을 더 구조적으로 다룰때 사용입니다.
     .then, .catch 메서드를 사용하여 처리를 하는데 then은 성공적인 결과를 처리하고 catch는 오류를 처리합니다.

   1. Promise.all() 에 대해 설명해주세요.

   - 여러개의 promise 객체를 동시에 처리하고 모든 promise가 성공적으로 완료 될 때 하나의 Promise로 결합됩니다.
     만약 하나라도 실패한다면 최종 promise도 실패입니다.
     이러한 특성으로 promise.all은 여러개의 비동기 작업을 병렬로 실행하고 모든 작업이 완료될 ㄸ까지 기다린 후 결과를 처리하는데 우용합니다.
     promise.all을 사용하면 여러개의 비동기 작업을 효율적으로 처리하고, 모든 자업이 완료될 때까지 기다린 후 결과를 처리할 수 있다라는 장점이 있습니다.

2. ⭐ Promise와 Callback를 비교 설명해주세요.

   - promise는 callback 함수보다 가독성이 좋고 오류 처리가 편리하여 비동기 작업을 다룰 때 더 유용합니다.
     최신 자바스크립트 프로젝트에서는 Promise와 async/await을 활용하여 비동기 코드를 작성하고 관리하는게 일반적인 프로젝트 방법입니다.

3. ⭐ Async, Await이 뭔지 그리고 사용 방법을 설명해주세요.

   - async, await은 자바스크립트의 비동기 처리를 좀 더 간편하게 다룰 수 있게 하는 기능입니다.
     async는 키워드를 함수 앞에 붙여 해당 함수가 비동기 함수임을 알려주고, 함수 내부에서 await 키워드를 사용하여 promise를 처리합니다.
     async는 항상 promise를 반환하고 내부에서 명시적으로 promise를 반환하지 않아도 자동으로 promise로 감싸져 반환됩니다.

   await은 async 함수 내에서만 사용이 되고 promise가 처리 될 때까지 await 뒤의 표현식을 기다립니다.

```js
function someAsyncFunction() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve("Async 작업 완료!");
    }, 2000);
  });
}
async function asyncTask() {
  console.log("작업 시작");

  try {
    const result = await someAsyncFunction();
    console.log(result);
  } catch (error) {
    console.error(error);
  }

  console.log("작업 완료");
}
asyncTask();
```

5. ⭐ Promise와 Async, Await의 차이를 설명해주세요.

- promise는 비동기 처리에 사용되는 객체로 내용은 실행 되었지만 결과를 아직 반환하지 못한 객체 입니다.
  3가지 상태가 존재하는데 pending(대기), fulfilled(이행), rejected(실패) 로 완료되지 않았다면 pending, 완료 되었다면 fulfilled, 실패하거나 오류가 발행 했다면 rejected 상태를 가집니다.

async/await은 최근에 나온 비동기 처리문법으로 callback이나 promise의 단점을 해결하기위 나왔습니다.
callback이나 promise의 최대 단점은 콜백지옥 .then 지옥이라고 말하는데 이걸 해결하기 위해 나온것이 async/await 입니다.
하지만 async/await 을 사용하기 위해서는 조건이있는데 await은 async 함수 안에서만 작동을 해야한다는 것입니다.

둘의 차이점은
첫번째론 에러핸들링입니다.
promise를 활용할 시에 catch 문을 사용해 에러 핸들링이 가능하지만 async/await 은 에러 핼들링 기능이 없어 try-catch문을 사용합니다.
두번째론 코드 가독성입니다.
promise는 코드가 길어지면 콜백지옥에 빠질 수있지만 async/await 은 비동기코드가 동기 코드처럼 읽히게 하여 코드 흐름을 이해하기 쉽고 코드 가독성을 좋게 합니다.

6. AJAX에 대해 설명해주세요.

- ajax(Asynchronous JavaScript and XML)란 자바스크립트를 이용해서 비동기적으로 서버와 브라우저가 데이터를 교환할 수 있는 통신 방식을 의미합니다. 서버로부터 웹페이즈를 받으면 브라우저 화면 전체를 갱신해야 하는데 AJAX를 사용함으로 페이지 일부만을 갱신하고도 동일한 효과를 볼 수있습니다. 일부분만 변경하기에 빠르고 부드럽게 웹페이지를 그릴 수 있습니다.
  서버는 HTML, XML, JSON등을 반환하는데, AJAX을 위한 데이터 형식은 JSON 을 사용하는 것이 일반적입니다.

7. ⭐ var, let, const 차이를 설명해주세요.
   세가지 모두 변수 선언 방식입니다.
   var는 함수스코프를 가지고 변수를 여러번 선언할 수 있고, 재선언이 가능합니다. 호이스팅으로 인해 선언 전에 사용해도 에러가 발생하지 않습니다. es6 이후 let , const가 나온 이후 사용을 지양합니다.
   let은 블록스코프를 가지고 변수를 한번만 선언할 수 있지만 재할당은 가능합니다. 호이스팅은 발생하지만 초기화되지 않은 상태로 호이스팅시 에러가 발생됩니다.
   const도 블록스코프를 가지며 변수를 선언할때 반드시 값을 할당해야합니다. 한번 할당된 값은 변경할 수 없습니다. 객체 내부의 속성이나 배열 내부의 요소는 변경이 가능합니다.
8. TDZ에 대해 설명해주세요.
   - TDZ(Temporal Dead Zone)란 직역하면 일시적 사각지대 입니다.
     const와 let은 변수를 선언하고 초기화한 다음 변수 값을 출력하는 순서로 동작하는데 초기화 되기전에 선언된 변수를 사용하려면 RefereneceError가 납니다. 이 변ㄴ수 선언과 초기화 사이에 일시적인 사각지대를 TDZ라고 합니다.
9. 함수 선언형과 함수 표현식의 차이에 대해 설명해주세요.
   함수 선언식은 함수명이 정의가 되어 있고 별도의 할당 명령이 없습니다.
   함수 표현식은 함수를 별도의 변수에 할당하는 것을 말합니다.
   두개의 큰 차이점은 호이스팅 입니다.
   함수 선언식은 함수 전체를 호이스팅해서 함수 선언전에도 함수를 사용할 수 있지만
   함수 표현식은 선언부만 호이스팅 되기 때문에 함수 선언 전에 함수를 사용하면 에러가 납니다.
10. ⭐ 이벤트 버블링과 캡처링에 대해 설명해주세요.

    1. ⭐ 이벤트 위임에 대해서 설명해주세요.
    2. 이벤트 위임의 동작 방식에 대해서 설명해주세요.

11. ⭐ 호이스팅과 발생하는 이유에 대해 설명해주세요.
12. 스코프 (Scope)에 대해 설명해주세요.
    1. 스코프 체인에 대해 설명해주세요.
13. ⭐ 클로져(Closure)에 대해 설명해주세요.
14. 실행 컨텍스트에 대해 설명해주세요.
    1. 렉시컬 환경(Lexical Environment)에 대해 설명해주세요.
15. 자바스크립트에서 일어나는 데이터 형변환에 대해 설명해주세요.
16. 자바스크립트가 동적 언어인 이유는 무엇인가요?
17. 프로토타입에 대해 설명해주세요.
18. 깊은 복사와 얕은 복사에 대해 설명해주세요.
19. 불변성을 유지하려면 어떻게 해야하나요?
20. Blocking과 Non-Blocking에 대해 설명해주세요.
21. ⭐ 동기와 비동기에 대해 설명해주세요.
22. ES6에서 새로 생긴 기능을 아는대로 말씀해주세요.
23. undefined, null, undeclared를 비교해주세요.
24. 자바스크립트를 멀티 쓰레드처럼 사용하는 방법이 뭔가요? / 자바스크립트에서 비동기
25. 로직이 어떻게 동작하는지 설명해주세요. (이벤트 루프)
    1. 태스크 큐와 마이크로 태스트 큐에는 어떤 함수가 들어가나요?
    2. requestAnimationFrame에 대해 설명해주세요.
26. 비동기적으로 실행되는 것을 동기적으로 코딩하는 방법이 있나요?
27. map과 forEach, reduce에 대해 설명해주세요.
28. 자바스크립트의 메모리 관리에 대해 아는 대로 설명해주세요
29. 클래스에 대해 설명해주세요.
30. 즉시 실행 함수 (IIFE)에 대해 설명해주세요.
31. 엄격 모드에 대해 설명해주세요.
    - ES5 부터 도입된 기능으로 기존에 무시되던 에러들을 무시하 않고 발생시킵니다.
      파일 전체에 적용할 수 있고 , 함수 스코프에 적용시킬 수 있지만, 블록스코프는 불가능합니다.
      특징으로는 var가 생략된 변수를 전역객체에 바인딩 하지 않는다
      제거할 수 없는 프로퍼티를 제거할 수 없다
      함수의 매개변수 이름은 중복될 수 없다
      일반 변수를 삭제할 수 없다
32. 콜 스택 (Call Stack)과 힙 (Heap)에 대해 설명해주세요.
33. Rest 연산자와 Spread 연산자에 대해 설명해주세요.
34. 제너레이터에 대해 설명해주세요.
    - 제너레이터는 이터레이터를 생성하는 함수입니다.
      일반함수와는 다르게 실행을 중단할 수 있고, 다시 실행할 수 있는 함수입니다.
      `function` 키워드로 생성하고 `yield` 키워드를 사용하여 값을 반환합니다.
      제너레이터를 호출하면 이터레이터 객체가 반환되며, 이터레이터의 `next()` 메서드를 호출하여 제너레이터 함수를 실행 할 수 있습니다.
35. 이터러블과 이터레이터 프로토콜에 대해 설명해주세요.
